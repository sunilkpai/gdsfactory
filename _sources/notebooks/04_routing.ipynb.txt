{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Routing optical and RF ports\n",
    "\n",
    "Optical and high speed RF ports have an orientation that routes need to follow to avoid sharp turns that produce reflections."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import gdsfactory as gf\n",
    "\n",
    "gf.config.set_plot_options(show_subports=False)\n",
    "gf.CONF.plotter = \"matplotlib\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "c = gf.Component()\n",
    "mmi1 = c << gf.components.mmi1x2()\n",
    "mmi2 = c << gf.components.mmi1x2()\n",
    "mmi2.move((100, 50))\n",
    "c.plot()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## get_route\n",
    "\n",
    "`get_route` returns a Manhattan route between 2 ports"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "gf.routing.get_route?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "c = gf.Component(\"sample_connect\")\n",
    "mmi1 = c << gf.components.mmi1x2()\n",
    "mmi2 = c << gf.components.mmi1x2()\n",
    "mmi2.move((100, 50))\n",
    "route = gf.routing.get_route(mmi1.ports[\"o2\"], mmi2.ports[\"o1\"])\n",
    "c.add(route.references)\n",
    "c.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "route"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Connect strip: Problem**\n",
    "\n",
    "sometimes there are obstacles that connect strip does not see!"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "c = gf.Component(\"sample_problem\")\n",
    "mmi1 = c << gf.components.mmi1x2()\n",
    "mmi2 = c << gf.components.mmi1x2()\n",
    "mmi2.move((110, 50))\n",
    "x = c << gf.components.cross(length=20)\n",
    "x.move((135, 20))\n",
    "route = gf.routing.get_route(mmi1.ports[\"o2\"], mmi2.ports[\"o2\"])\n",
    "c.add(route.references)\n",
    "c.plot()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Solution: Connect strip way points**\n",
    "\n",
    "You can also specify the points along the route"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "gf.routing.get_route_waypoints?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "c = gf.Component(\"sample_avoid_obstacle\")\n",
    "mmi1 = c << gf.components.mmi1x2()\n",
    "mmi2 = c << gf.components.mmi1x2()\n",
    "mmi2.move((110, 50))\n",
    "x = c << gf.components.cross(length=20)\n",
    "x.move((135, 20))\n",
    "\n",
    "x0 = mmi1.ports[\"o3\"].x\n",
    "y0 = mmi1.ports[\"o3\"].y\n",
    "\n",
    "\n",
    "x2 = mmi2.ports[\"o3\"].x\n",
    "y2 = mmi2.ports[\"o3\"].y\n",
    "\n",
    "route = gf.routing.get_route_from_waypoints(\n",
    "    [(x0, y0), (x2 + 40, y0), (x2 + 40, y2), (x2, y2)]\n",
    ")\n",
    "c.add(route.references)\n",
    "c.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "route.length"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "route.ports"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "route.references"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Lets say that we want to extrude the waveguide using a different waveguide crosssection, for example using a different layer"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import gdsfactory as gf\n",
    "\n",
    "c = gf.Component(\"sample_connect\")\n",
    "mmi1 = c << gf.components.mmi1x2()\n",
    "mmi2 = c << gf.components.mmi1x2()\n",
    "mmi2.move((100, 50))\n",
    "route = gf.routing.get_route(\n",
    "    mmi1.ports[\"o3\"], mmi2.ports[\"o1\"], cross_section=gf.cross_section.metal1\n",
    ")\n",
    "c.add(route.references)\n",
    "c.plot()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## auto-widen\n",
    "\n",
    "To reduce loss and phase errors you can also auto-widen waveguide routes straight sections that are longer than a certain length."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import gdsfactory as gf\n",
    "\n",
    "c = gf.Component(\"sample_connect\")\n",
    "mmi1 = c << gf.components.mmi1x2()\n",
    "mmi2 = c << gf.components.mmi1x2()\n",
    "mmi2.move((200, 50))\n",
    "route = gf.routing.get_route(\n",
    "    mmi1.ports[\"o3\"],\n",
    "    mmi2.ports[\"o1\"],\n",
    "    cross_section=gf.cross_section.strip,\n",
    "    auto_widen=True,\n",
    "    width_wide=2,\n",
    "    auto_widen_minimum_length=100,\n",
    ")\n",
    "c.add(route.references)\n",
    "c.plot()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## get_route_from_waypoints\n",
    "\n",
    "Sometimes you need to set up a route with custom waypoints. `get_route_from_waypoints` is a manual version of `get_route`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import gdsfactory as gf\n",
    "\n",
    "c = gf.Component(\"waypoints_sample\")\n",
    "\n",
    "w = gf.components.straight()\n",
    "left = c << w\n",
    "right = c << w\n",
    "right.move((100, 80))\n",
    "\n",
    "obstacle = gf.components.rectangle(size=(100, 10))\n",
    "obstacle1 = c << obstacle\n",
    "obstacle2 = c << obstacle\n",
    "obstacle1.ymin = 40\n",
    "obstacle2.xmin = 25\n",
    "\n",
    "\n",
    "p0x, p0y = left.ports[\"o2\"].midpoint\n",
    "p1x, p1y = right.ports[\"o2\"].midpoint\n",
    "o = 10  # vertical offset to overcome bottom obstacle\n",
    "ytop = 20\n",
    "\n",
    "\n",
    "routes = gf.routing.get_route_from_waypoints(\n",
    "    [\n",
    "        (p0x, p0y),\n",
    "        (p0x + o, p0y),\n",
    "        (p0x + o, ytop),\n",
    "        (p1x + o, ytop),\n",
    "        (p1x + o, p1y),\n",
    "        (p1x, p1y),\n",
    "    ],\n",
    ")\n",
    "c.add(routes.references)\n",
    "c.plot()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## get_route_from_steps\n",
    "\n",
    "As you can see waypoints can only change one point (x or y) at a time, making the waypoint definition a bit redundant.\n",
    "\n",
    "You can also use a `get_route_from_steps` which is a more concise route definition, that supports defining only the new steps `x` or `y` together with increments `dx` or `dy`\n",
    "\n",
    "`get_route_from_steps` is a manual version of `get_route` and a more concise and convenient version of `get_route_from_waypoints`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import gdsfactory as gf\n",
    "\n",
    "c = gf.Component(\"get_route_from_steps\")\n",
    "w = gf.components.straight()\n",
    "left = c << w\n",
    "right = c << w\n",
    "right.move((100, 80))\n",
    "\n",
    "obstacle = gf.components.rectangle(size=(100, 10))\n",
    "obstacle1 = c << obstacle\n",
    "obstacle2 = c << obstacle\n",
    "obstacle1.ymin = 40\n",
    "obstacle2.xmin = 25\n",
    "\n",
    "port1 = left.ports[\"o2\"]\n",
    "port2 = right.ports[\"o2\"]\n",
    "\n",
    "routes = gf.routing.get_route_from_steps(\n",
    "    port1=port1,\n",
    "    port2=port2,\n",
    "    steps=[\n",
    "        {\"x\": 20, \"y\": 0},\n",
    "        {\"x\": 20, \"y\": 20},\n",
    "        {\"x\": 120, \"y\": 20},\n",
    "        {\"x\": 120, \"y\": 80},\n",
    "    ],\n",
    ")\n",
    "c.add(routes.references)\n",
    "c.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import gdsfactory as gf\n",
    "\n",
    "c = gf.Component(\"get_route_from_steps_shorter_syntax\")\n",
    "w = gf.components.straight()\n",
    "left = c << w\n",
    "right = c << w\n",
    "right.move((100, 80))\n",
    "\n",
    "obstacle = gf.components.rectangle(size=(100, 10))\n",
    "obstacle1 = c << obstacle\n",
    "obstacle2 = c << obstacle\n",
    "obstacle1.ymin = 40\n",
    "obstacle2.xmin = 25\n",
    "\n",
    "port1 = left.ports[\"o2\"]\n",
    "port2 = right.ports[\"o2\"]\n",
    "\n",
    "routes = gf.routing.get_route_from_steps(\n",
    "    port1=port1,\n",
    "    port2=port2,\n",
    "    steps=[\n",
    "        {\"x\": 20},\n",
    "        {\"y\": 20},\n",
    "        {\"x\": 120},\n",
    "        {\"y\": 80},\n",
    "    ],\n",
    ")\n",
    "c.add(routes.references)\n",
    "c.plot()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## get_bundle\n",
    "\n",
    "**Problem**\n",
    "\n",
    "See the route collisions When connecting groups of ports using a regular manhattan single-route router  such as `get route`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import gdsfactory as gf\n",
    "\n",
    "xs_top = [0, 10, 20, 40, 50, 80]\n",
    "pitch = 127\n",
    "N = len(xs_top)\n",
    "xs_bottom = [(i - N / 2) * pitch for i in range(N)]\n",
    "layer = (1, 0)\n",
    "\n",
    "top_ports = [\n",
    "    gf.Port(f\"top_{i}\", (xs_top[i], 0), 0.5, 270, layer=layer) for i in range(N)\n",
    "]\n",
    "\n",
    "bottom_ports = [\n",
    "    gf.Port(f\"bottom_{i}\", (xs_bottom[i], -100), 0.5, 90, layer=layer) for i in range(N)\n",
    "]\n",
    "\n",
    "c = gf.Component(name=\"connect_bundle\")\n",
    "\n",
    "for p1, p2 in zip(top_ports, bottom_ports):\n",
    "    route = gf.routing.get_route(p1, p2)\n",
    "    c.add(route.references)\n",
    "\n",
    "c.plot()\n",
    "c.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**solution**\n",
    "\n",
    "`get_bundle` provides you with river routing capabilities, that you can use to route bundles of ports without collisions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "c = gf.Component(name=\"connect_bundle\")\n",
    "routes = gf.routing.get_bundle(top_ports, bottom_ports)\n",
    "for route in routes:\n",
    "    c.add(route.references)\n",
    "\n",
    "c.plot()\n",
    "c.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import gdsfactory as gf\n",
    "\n",
    "ys_right = [0, 10, 20, 40, 50, 80]\n",
    "pitch = 127.0\n",
    "N = len(ys_right)\n",
    "ys_left = [(i - N / 2) * pitch for i in range(N)]\n",
    "layer = (1, 0)\n",
    "\n",
    "right_ports = [\n",
    "    gf.Port(f\"R_{i}\", (0, ys_right[i]), width=0.5, orientation=180, layer=layer)\n",
    "    for i in range(N)\n",
    "]\n",
    "left_ports = [\n",
    "    gf.Port(\n",
    "        f\"L_{i}\".format(i), (-200, ys_left[i]), width=0.5, orientation=0, layer=layer\n",
    "    )\n",
    "    for i in range(N)\n",
    "]\n",
    "\n",
    "# you can also mess up the port order and it will sort them by default\n",
    "left_ports.reverse()\n",
    "\n",
    "c = gf.Component(name=\"connect_bundle2\")\n",
    "routes = gf.routing.get_bundle(\n",
    "    left_ports, right_ports, sort_ports=True, start_straight_length=100\n",
    ")\n",
    "for route in routes:\n",
    "    c.add(route.references)\n",
    "c.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "xs_top = [0, 10, 20, 40, 50, 80]\n",
    "pitch = 127.0\n",
    "N = len(xs_top)\n",
    "xs_bottom = [(i - N / 2) * pitch for i in range(N)]\n",
    "layer = (1, 0)\n",
    "\n",
    "top_ports = [\n",
    "    gf.Port(\n",
    "        f\"top_{i}\", midpoint=(xs_top[i], 0), width=0.5, orientation=270, layer=layer\n",
    "    )\n",
    "    for i in range(N)\n",
    "]\n",
    "\n",
    "bot_ports = [\n",
    "    gf.Port(\n",
    "        f\"bot_{i}\",\n",
    "        midpoint=(xs_bottom[i], -300),\n",
    "        width=0.5,\n",
    "        orientation=90,\n",
    "        layer=layer,\n",
    "    )\n",
    "    for i in range(N)\n",
    "]\n",
    "\n",
    "c = gf.Component(name=\"connect_bundle\")\n",
    "routes = gf.routing.get_bundle(\n",
    "    top_ports, bot_ports, separation=5.0, end_straight_length=100\n",
    ")\n",
    "for route in routes:\n",
    "    c.add(route.references)\n",
    "\n",
    "c.plot()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "`get_bundle` can also route bundles through corners"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import gdsfactory as gf\n",
    "from gdsfactory.cell import cell\n",
    "from gdsfactory.component import Component\n",
    "from gdsfactory.port import Port\n",
    "\n",
    "\n",
    "@cell\n",
    "def test_connect_corner(N=6, config=\"A\"):\n",
    "    d = 10.0\n",
    "    sep = 5.0\n",
    "    top_cell = gf.Component(name=\"connect_corner\")\n",
    "    layer = (1, 0)\n",
    "\n",
    "    if config in [\"A\", \"B\"]:\n",
    "        a = 100.0\n",
    "        ports_A_TR = [\n",
    "            Port(\n",
    "                \"A_TR_{}\".format(i),\n",
    "                midpoint=(d, a / 2 + i * sep),\n",
    "                width=0.5,\n",
    "                orientation=0,\n",
    "                layer=layer,\n",
    "            )\n",
    "            for i in range(N)\n",
    "        ]\n",
    "        ports_A_TL = [\n",
    "            Port(\n",
    "                \"A_TL_{}\".format(i),\n",
    "                midpoint=(-d, a / 2 + i * sep),\n",
    "                width=0.5,\n",
    "                orientation=180,\n",
    "                layer=layer,\n",
    "            )\n",
    "            for i in range(N)\n",
    "        ]\n",
    "        ports_A_BR = [\n",
    "            Port(\n",
    "                \"A_BR_{}\".format(i),\n",
    "                midpoint=(d, -a / 2 - i * sep),\n",
    "                width=0.5,\n",
    "                orientation=0,\n",
    "                layer=layer,\n",
    "            )\n",
    "            for i in range(N)\n",
    "        ]\n",
    "        ports_A_BL = [\n",
    "            Port(\n",
    "                \"A_BL_{}\".format(i),\n",
    "                midpoint=(-d, -a / 2 - i * sep),\n",
    "                width=0.5,\n",
    "                orientation=180,\n",
    "                layer=layer,\n",
    "            )\n",
    "            for i in range(N)\n",
    "        ]\n",
    "\n",
    "        ports_A = [ports_A_TR, ports_A_TL, ports_A_BR, ports_A_BL]\n",
    "\n",
    "        ports_B_TR = [\n",
    "            Port(\n",
    "                \"B_TR_{}\".format(i),\n",
    "                midpoint=(a / 2 + i * sep, d),\n",
    "                width=0.5,\n",
    "                orientation=90,\n",
    "                layer=layer,\n",
    "            )\n",
    "            for i in range(N)\n",
    "        ]\n",
    "        ports_B_TL = [\n",
    "            Port(\n",
    "                \"B_TL_{}\".format(i),\n",
    "                midpoint=(-a / 2 - i * sep, d),\n",
    "                width=0.5,\n",
    "                orientation=90,\n",
    "                layer=layer,\n",
    "            )\n",
    "            for i in range(N)\n",
    "        ]\n",
    "        ports_B_BR = [\n",
    "            Port(\n",
    "                \"B_BR_{}\".format(i),\n",
    "                midpoint=(a / 2 + i * sep, -d),\n",
    "                width=0.5,\n",
    "                orientation=270,\n",
    "                layer=layer,\n",
    "            )\n",
    "            for i in range(N)\n",
    "        ]\n",
    "        ports_B_BL = [\n",
    "            Port(\n",
    "                \"B_BL_{}\".format(i),\n",
    "                midpoint=(-a / 2 - i * sep, -d),\n",
    "                width=0.5,\n",
    "                orientation=270,\n",
    "                layer=layer,\n",
    "            )\n",
    "            for i in range(N)\n",
    "        ]\n",
    "\n",
    "        ports_B = [ports_B_TR, ports_B_TL, ports_B_BR, ports_B_BL]\n",
    "\n",
    "    elif config in [\"C\", \"D\"]:\n",
    "        a = N * sep + 2 * d\n",
    "        ports_A_TR = [\n",
    "            Port(\n",
    "                \"A_TR_{}\".format(i),\n",
    "                midpoint=(a, d + i * sep),\n",
    "                width=0.5,\n",
    "                orientation=0,\n",
    "                layer=layer,\n",
    "            )\n",
    "            for i in range(N)\n",
    "        ]\n",
    "        ports_A_TL = [\n",
    "            Port(\n",
    "                \"A_TL_{}\".format(i),\n",
    "                midpoint=(-a, d + i * sep),\n",
    "                width=0.5,\n",
    "                orientation=180,\n",
    "                layer=layer,\n",
    "            )\n",
    "            for i in range(N)\n",
    "        ]\n",
    "        ports_A_BR = [\n",
    "            Port(\n",
    "                \"A_BR_{}\".format(i),\n",
    "                midpoint=(a, -d - i * sep),\n",
    "                width=0.5,\n",
    "                orientation=0,\n",
    "                layer=layer,\n",
    "            )\n",
    "            for i in range(N)\n",
    "        ]\n",
    "        ports_A_BL = [\n",
    "            Port(\n",
    "                \"A_BL_{}\".format(i),\n",
    "                midpoint=(-a, -d - i * sep),\n",
    "                width=0.5,\n",
    "                orientation=180,\n",
    "                layer=layer,\n",
    "            )\n",
    "            for i in range(N)\n",
    "        ]\n",
    "\n",
    "        ports_A = [ports_A_TR, ports_A_TL, ports_A_BR, ports_A_BL]\n",
    "\n",
    "        ports_B_TR = [\n",
    "            Port(\n",
    "                \"B_TR_{}\".format(i),\n",
    "                midpoint=(d + i * sep, a),\n",
    "                width=0.5,\n",
    "                orientation=90,\n",
    "                layer=layer,\n",
    "            )\n",
    "            for i in range(N)\n",
    "        ]\n",
    "        ports_B_TL = [\n",
    "            Port(\n",
    "                \"B_TL_{}\".format(i),\n",
    "                midpoint=(-d - i * sep, a),\n",
    "                width=0.5,\n",
    "                orientation=90,\n",
    "                layer=layer,\n",
    "            )\n",
    "            for i in range(N)\n",
    "        ]\n",
    "        ports_B_BR = [\n",
    "            Port(\n",
    "                \"B_BR_{}\".format(i),\n",
    "                midpoint=(d + i * sep, -a),\n",
    "                width=0.5,\n",
    "                orientation=270,\n",
    "                layer=layer,\n",
    "            )\n",
    "            for i in range(N)\n",
    "        ]\n",
    "        ports_B_BL = [\n",
    "            Port(\n",
    "                \"B_BL_{}\".format(i),\n",
    "                midpoint=(-d - i * sep, -a),\n",
    "                width=0.5,\n",
    "                orientation=270,\n",
    "                layer=layer,\n",
    "            )\n",
    "            for i in range(N)\n",
    "        ]\n",
    "\n",
    "        ports_B = [ports_B_TR, ports_B_TL, ports_B_BR, ports_B_BL]\n",
    "\n",
    "    if config in [\"A\", \"C\"]:\n",
    "        for ports1, ports2 in zip(ports_A, ports_B):\n",
    "            routes = gf.routing.get_bundle(ports1, ports2, layer=(2, 0), radius=5)\n",
    "            for route in routes:\n",
    "                top_cell.add(route.references)\n",
    "\n",
    "    elif config in [\"B\", \"D\"]:\n",
    "        for ports1, ports2 in zip(ports_A, ports_B):\n",
    "            routes = gf.routing.get_bundle(ports2, ports1, layer=(2, 0), radius=5)\n",
    "            for route in routes:\n",
    "                top_cell.add(route.references)\n",
    "\n",
    "    return top_cell\n",
    "\n",
    "\n",
    "c = test_connect_corner(config=\"A\")\n",
    "c.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "c = test_connect_corner(config=\"C\")\n",
    "c.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "@cell\n",
    "def test_connect_bundle_udirect(dy=200, angle=270, layer=(1, 0)):\n",
    "\n",
    "    xs1 = [-100, -90, -80, -55, -35, 24, 0] + [200, 210, 240]\n",
    "\n",
    "    axis = \"X\" if angle in [0, 180] else \"Y\"\n",
    "\n",
    "    pitch = 10.0\n",
    "    N = len(xs1)\n",
    "    xs2 = [70 + i * pitch for i in range(N)]\n",
    "\n",
    "    if axis == \"X\":\n",
    "        ports1 = [\n",
    "            Port(f\"top_{i}\", (0, xs1[i]), 0.5, angle, layer=layer) for i in range(N)\n",
    "        ]\n",
    "\n",
    "        ports2 = [\n",
    "            Port(f\"bottom_{i}\", (dy, xs2[i]), 0.5, angle, layer=layer) for i in range(N)\n",
    "        ]\n",
    "\n",
    "    else:\n",
    "        ports1 = [\n",
    "            Port(f\"top_{i}\", (xs1[i], 0), 0.5, angle, layer=layer) for i in range(N)\n",
    "        ]\n",
    "\n",
    "        ports2 = [\n",
    "            Port(f\"bottom_{i}\", (xs2[i], dy), 0.5, angle, layer=layer) for i in range(N)\n",
    "        ]\n",
    "\n",
    "    top_cell = Component(name=\"connect_bundle_udirect\")\n",
    "    routes = gf.routing.get_bundle(ports1, ports2, radius=10.0)\n",
    "    for route in routes:\n",
    "        top_cell.add(route.references)\n",
    "\n",
    "    return top_cell\n",
    "\n",
    "\n",
    "c = test_connect_bundle_udirect()\n",
    "c.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "@cell\n",
    "def test_connect_bundle_u_indirect(dy=-200, angle=180, layer=(1, 0)):\n",
    "    xs1 = [-100, -90, -80, -55, -35] + [200, 210, 240]\n",
    "    axis = \"X\" if angle in [0, 180] else \"Y\"\n",
    "    pitch = 10.0\n",
    "    N = len(xs1)\n",
    "    xs2 = [50 + i * pitch for i in range(N)]\n",
    "\n",
    "    a1 = angle\n",
    "    a2 = a1 + 180\n",
    "\n",
    "    if axis == \"X\":\n",
    "        ports1 = [\n",
    "            Port(\"top_{}\".format(i), (0, xs1[i]), 0.5, a1, layer=layer)\n",
    "            for i in range(N)\n",
    "        ]\n",
    "\n",
    "        ports2 = [\n",
    "            Port(\"bot_{}\".format(i), (dy, xs2[i]), 0.5, a2, layer=layer)\n",
    "            for i in range(N)\n",
    "        ]\n",
    "\n",
    "    else:\n",
    "        ports1 = [\n",
    "            Port(\"top_{}\".format(i), (xs1[i], 0), 0.5, a1, layer=layer)\n",
    "            for i in range(N)\n",
    "        ]\n",
    "\n",
    "        ports2 = [\n",
    "            Port(\"bot_{}\".format(i), (xs2[i], dy), 0.5, a2, layer=layer)\n",
    "            for i in range(N)\n",
    "        ]\n",
    "\n",
    "    top_cell = Component(\"connect_bundle_u_indirect\")\n",
    "    routes = gf.routing.get_bundle(\n",
    "        ports1,\n",
    "        ports2,\n",
    "        bend=gf.components.bend_euler,\n",
    "        radius=10,\n",
    "    )\n",
    "    for route in routes:\n",
    "        top_cell.add(route.references)\n",
    "\n",
    "    return top_cell\n",
    "\n",
    "\n",
    "c = test_connect_bundle_u_indirect(angle=0)\n",
    "c.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import gdsfactory as gf\n",
    "\n",
    "\n",
    "@gf.cell\n",
    "def test_north_to_south(layer=(1, 0)):\n",
    "    dy = 200.0\n",
    "    xs1 = [-500, -300, -100, -90, -80, -55, -35, 200, 210, 240, 500, 650]\n",
    "\n",
    "    pitch = 10.0\n",
    "    N = len(xs1)\n",
    "    xs2 = [-20 + i * pitch for i in range(N // 2)]\n",
    "    xs2 += [400 + i * pitch for i in range(N // 2)]\n",
    "\n",
    "    a1 = 90\n",
    "    a2 = a1 + 180\n",
    "\n",
    "    ports1 = [\n",
    "        gf.Port(\"top_{}\".format(i), (xs1[i], 0), 0.5, a1, layer=layer) for i in range(N)\n",
    "    ]\n",
    "    ports2 = [\n",
    "        gf.Port(\"bot_{}\".format(i), (xs2[i], dy), 0.5, a2, layer=layer)\n",
    "        for i in range(N)\n",
    "    ]\n",
    "\n",
    "    c = gf.Component()\n",
    "    routes = gf.routing.get_bundle(ports1, ports2, auto_widen=False)\n",
    "    for route in routes:\n",
    "        c.add(route.references)\n",
    "\n",
    "    return c\n",
    "\n",
    "\n",
    "c = test_north_to_south()\n",
    "c.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def demo_connect_bundle():\n",
    "    \"\"\"combines all the connect_bundle tests\"\"\"\n",
    "    y = 400.0\n",
    "    x = 500\n",
    "    y0 = 900\n",
    "    dy = 200.0\n",
    "    c = Component(\"connect_bundle\")\n",
    "    for j, s in enumerate([-1, 1]):\n",
    "        for i, angle in enumerate([0, 90, 180, 270]):\n",
    "            _cmp = test_connect_bundle_u_indirect(dy=s * dy, angle=angle)\n",
    "            _cmp_ref = _cmp.ref(position=(i * x, j * y))\n",
    "            c.add(_cmp_ref)\n",
    "\n",
    "            _cmp = test_connect_bundle_udirect(dy=s * dy, angle=angle)\n",
    "            _cmp_ref = _cmp.ref(position=(i * x, j * y + y0))\n",
    "            c.add(_cmp_ref)\n",
    "\n",
    "    for i, config in enumerate([\"A\", \"B\", \"C\", \"D\"]):\n",
    "        _cmp = test_connect_corner(config=config)\n",
    "        _cmp_ref = _cmp.ref(position=(i * x, 1700))\n",
    "        c.add(_cmp_ref)\n",
    "\n",
    "    # _cmp = test_facing_ports()\n",
    "    # _cmp_ref = _cmp.ref(position=(800, 1820))\n",
    "    # c.add(_cmp_ref)\n",
    "\n",
    "    return c\n",
    "\n",
    "\n",
    "c = demo_connect_bundle()\n",
    "c.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import gdsfactory as gf\n",
    "\n",
    "c = gf.Component(\"route_bend_5um\")\n",
    "c1 = c << gf.components.mmi2x2()\n",
    "c2 = c << gf.components.mmi2x2()\n",
    "\n",
    "c2.move((100, 50))\n",
    "routes = gf.routing.get_bundle(\n",
    "    [c1.ports[\"o4\"], c1.ports[\"o3\"]], [c2.ports[\"o1\"], c2.ports[\"o2\"]], radius=5\n",
    ")\n",
    "for route in routes:\n",
    "    c.add(route.references)\n",
    "c.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import gdsfactory as gf\n",
    "\n",
    "c = gf.Component(\"electrical\")\n",
    "c1 = c << gf.components.pad()\n",
    "c2 = c << gf.components.pad()\n",
    "c2.move((200, 100))\n",
    "routes = gf.routing.get_bundle(\n",
    "    [c1.ports[\"e3\"]], [c2.ports[\"e1\"]], cross_section=gf.cross_section.metal1\n",
    ")\n",
    "for route in routes:\n",
    "    c.add(route.references)\n",
    "c.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "c = gf.Component(\"get_bundle_with_ubends_bend_from_top\")\n",
    "pad_array = gf.components.pad_array()\n",
    "\n",
    "c1 = c << pad_array\n",
    "c2 = c << pad_array\n",
    "c2.rotate(90)\n",
    "c2.movex(1000)\n",
    "c2.ymax = -200\n",
    "\n",
    "routes_bend180 = gf.routing.get_routes_bend180(\n",
    "    ports=c2.get_ports_list(),\n",
    "    radius=75 / 2,\n",
    "    cross_section=gf.cross_section.metal1,\n",
    "    bend_port1=\"e1\",\n",
    "    bend_port2=\"e2\",\n",
    ")\n",
    "c.add(routes_bend180.references)\n",
    "\n",
    "routes = gf.routing.get_bundle(\n",
    "    c1.get_ports_list(), routes_bend180.ports, cross_section=gf.cross_section.metal1\n",
    ")\n",
    "for route in routes:\n",
    "    c.add(route.references)\n",
    "c.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "c = gf.Component(\"get_bundle_with_ubends_bend_from_bottom\")\n",
    "pad_array = gf.components.pad_array()\n",
    "\n",
    "c1 = c << pad_array\n",
    "c2 = c << pad_array\n",
    "c2.rotate(90)\n",
    "c2.movex(1000)\n",
    "c2.ymax = -200\n",
    "\n",
    "routes_bend180 = gf.routing.get_routes_bend180(\n",
    "    ports=c2.get_ports_list(),\n",
    "    radius=75 / 2,\n",
    "    cross_section=gf.cross_section.metal1,\n",
    "    bend_port1=\"e2\",\n",
    "    bend_port2=\"e1\",\n",
    ")\n",
    "c.add(routes_bend180.references)\n",
    "\n",
    "routes = gf.routing.get_bundle(\n",
    "    c1.get_ports_list(), routes_bend180.ports, cross_section=gf.cross_section.metal1\n",
    ")\n",
    "for route in routes:\n",
    "    c.add(route.references)\n",
    "c.plot()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Problem**\n",
    "\n",
    "Sometimes 90 degrees routes do not have enough space for a Manhattan route"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import gdsfactory as gf\n",
    "\n",
    "c = gf.Component(\"route_fail_1\")\n",
    "c1 = c << gf.components.nxn(east=3, ysize=20)\n",
    "c2 = c << gf.components.nxn(west=3)\n",
    "c2.move((80, 0))\n",
    "c.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import gdsfactory as gf\n",
    "\n",
    "c = gf.Component(\"route_fail_1\")\n",
    "c1 = c << gf.components.nxn(east=3, ysize=20)\n",
    "c2 = c << gf.components.nxn(west=3)\n",
    "c2.move((80, 0))\n",
    "routes = gf.routing.get_bundle(\n",
    "    c1.get_ports_list(orientation=0),\n",
    "    c2.get_ports_list(orientation=180),\n",
    "    auto_widen=False,\n",
    ")\n",
    "for route in routes:\n",
    "    c.add(route.references)\n",
    "c.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "c = gf.Component(\"route_fail_2\")\n",
    "pitch = 2.0\n",
    "ys_left = [0, 10, 20]\n",
    "N = len(ys_left)\n",
    "ys_right = [(i - N / 2) * pitch for i in range(N)]\n",
    "layer = (1, 0)\n",
    "\n",
    "right_ports = [\n",
    "    gf.Port(f\"R_{i}\", (0, ys_right[i]), 0.5, 180, layer=layer) for i in range(N)\n",
    "]\n",
    "left_ports = [\n",
    "    gf.Port(f\"L_{i}\", (-50, ys_left[i]), 0.5, 0, layer=layer) for i in range(N)\n",
    "]\n",
    "left_ports.reverse()\n",
    "routes = gf.routing.get_bundle(right_ports, left_ports, radius=5)\n",
    "\n",
    "for i, route in enumerate(routes):\n",
    "    c.add(route.references)\n",
    "c.plot()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Solution**\n",
    "\n",
    "Add Sbend routes using `get_bundle_sbend`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import gdsfactory as gf\n",
    "\n",
    "c = gf.Component(\"route_solution_1_get_bundle_sbend\")\n",
    "c1 = c << gf.components.nxn(east=3, ysize=20)\n",
    "c2 = c << gf.components.nxn(west=3)\n",
    "c2.move((80, 0))\n",
    "routes = gf.routing.get_bundle_sbend(\n",
    "    c1.get_ports_list(orientation=0), c2.get_ports_list(orientation=180)\n",
    ")\n",
    "c.add(routes.references)\n",
    "c.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "routes"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "c = gf.Component(\"route_solution_2_get_bundle_sbend\")\n",
    "route = gf.routing.get_bundle_sbend(right_ports, left_ports)\n",
    "c.add(route.references)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## get_bundle_from_waypoints\n",
    "\n",
    "While `get_bundle` routes bundles of ports automatically, you can also use `get_bundle_from_waypoints` to manually specify the route waypoints.\n",
    "\n",
    "You can think of `get_bundle_from_waypoints` as a manual version of `get_bundle`\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import gdsfactory as gf\n",
    "\n",
    "\n",
    "@gf.cell\n",
    "def test_connect_bundle_waypoints(layer=(1, 0)):\n",
    "    \"\"\"Connect bundle of ports with bundle of routes following a list of waypoints.\"\"\"\n",
    "    ys1 = np.array([0, 5, 10, 15, 30, 40, 50, 60]) + 0.0\n",
    "    ys2 = np.array([0, 10, 20, 30, 70, 90, 110, 120]) + 500.0\n",
    "    N = ys1.size\n",
    "\n",
    "    ports1 = [\n",
    "        gf.Port(\n",
    "            name=f\"A_{i}\", midpoint=(0, ys1[i]), width=0.5, orientation=0, layer=layer\n",
    "        )\n",
    "        for i in range(N)\n",
    "    ]\n",
    "    ports2 = [\n",
    "        gf.Port(\n",
    "            name=f\"B_{i}\",\n",
    "            midpoint=(500, ys2[i]),\n",
    "            width=0.5,\n",
    "            orientation=180,\n",
    "            layer=layer,\n",
    "        )\n",
    "        for i in range(N)\n",
    "    ]\n",
    "\n",
    "    p0 = ports1[0].position\n",
    "\n",
    "    c = gf.Component(\"B\")\n",
    "    c.add_ports(ports1)\n",
    "    c.add_ports(ports2)\n",
    "    waypoints = [\n",
    "        p0 + (200, 0),\n",
    "        p0 + (200, -200),\n",
    "        p0 + (400, -200),\n",
    "        (p0[0] + 400, ports2[0].y),\n",
    "    ]\n",
    "\n",
    "    routes = gf.routing.get_bundle_from_waypoints(ports1, ports2, waypoints)\n",
    "    lengths = {}\n",
    "    for i, route in enumerate(routes):\n",
    "        c.add(route.references)\n",
    "        lengths[i] = route.length\n",
    "\n",
    "    return c\n",
    "\n",
    "\n",
    "cell = test_connect_bundle_waypoints()\n",
    "cell.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import gdsfactory as gf\n",
    "\n",
    "c = gf.Component()\n",
    "r = c << gf.components.array(\n",
    "    component=gf.components.straight, rows=2, columns=1, spacing=(0, 20)\n",
    ")\n",
    "\n",
    "r.movex(60)\n",
    "r.movey(40)\n",
    "\n",
    "lt = c << gf.components.straight(length=15)\n",
    "lb = c << gf.components.straight(length=5)\n",
    "lt.movey(5)\n",
    "\n",
    "ports1 = lt.get_ports_list(orientation=0) + lb.get_ports_list(orientation=0)\n",
    "ports2 = r.get_ports_list(orientation=180)\n",
    "\n",
    "\n",
    "dx = 20\n",
    "p0 = ports1[0].midpoint + (dx, 0)\n",
    "p1 = (ports1[0].midpoint[0] + dx, ports2[0].midpoint[1])\n",
    "waypoints = (p0, p1)\n",
    "\n",
    "routes = gf.routing.get_bundle_from_waypoints(ports1, ports2, waypoints=waypoints)\n",
    "for route in routes:\n",
    "    c.add(route.references)\n",
    "c.plot()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## get_bundle_from_steps"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import gdsfactory as gf\n",
    "\n",
    "c = gf.Component(\"get_route_from_steps_sample\")\n",
    "w = gf.components.array(\n",
    "    gf.partial(gf.components.straight, layer=(2, 0)),\n",
    "    rows=3,\n",
    "    columns=1,\n",
    "    spacing=(0, 50),\n",
    ")\n",
    "\n",
    "left = c << w\n",
    "right = c << w\n",
    "right.move((200, 100))\n",
    "p1 = left.get_ports_list(orientation=0)\n",
    "p2 = right.get_ports_list(orientation=180)\n",
    "\n",
    "routes = gf.routing.get_bundle_from_steps(\n",
    "    p1,\n",
    "    p2,\n",
    "    steps=[{\"x\": 150}],\n",
    ")\n",
    "\n",
    "for route in routes:\n",
    "    c.add(route.references)\n",
    "\n",
    "c.plot()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## get_bundle_path_length_match\n",
    "\n",
    "Sometimes you need to set up a route a bundle of ports that need to keep the same lengths"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import gdsfactory as gf\n",
    "\n",
    "c = gf.Component(\"path_length_match_sample\")\n",
    "dy = 2000.0\n",
    "xs1 = [-500, -300, -100, -90, -80, -55, -35, 200, 210, 240, 500, 650]\n",
    "\n",
    "pitch = 100.0\n",
    "N = len(xs1)\n",
    "xs2 = [-20 + i * pitch for i in range(N)]\n",
    "\n",
    "a1 = 90\n",
    "a2 = a1 + 180\n",
    "layer = (1, 0)\n",
    "\n",
    "ports1 = [gf.Port(f\"top_{i}\", (xs1[i], 0), 0.5, a1, layer=layer) for i in range(N)]\n",
    "ports2 = [gf.Port(f\"bot_{i}\", (xs2[i], dy), 0.5, a2, layer=layer) for i in range(N)]\n",
    "\n",
    "routes = gf.routing.get_bundle_path_length_match(ports1, ports2)\n",
    "\n",
    "for route in routes:\n",
    "    c.add(route.references)\n",
    "    print(route.length)\n",
    "c.plot()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Add extra length\n",
    "\n",
    "You can also add some extra length to all the routes"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import gdsfactory as gf\n",
    "\n",
    "c = gf.Component(\"path_length_match_sample\")\n",
    "\n",
    "dy = 2000.0\n",
    "xs1 = [-500, -300, -100, -90, -80, -55, -35, 200, 210, 240, 500, 650]\n",
    "\n",
    "pitch = 100.0\n",
    "N = len(xs1)\n",
    "xs2 = [-20 + i * pitch for i in range(N)]\n",
    "\n",
    "a1 = 90\n",
    "a2 = a1 + 180\n",
    "layer = (1, 0)\n",
    "\n",
    "ports1 = [gf.Port(f\"top_{i}\", (xs1[i], 0), 0.5, a1, layer=layer) for i in range(N)]\n",
    "ports2 = [gf.Port(f\"bot_{i}\", (xs2[i], dy), 0.5, a2, layer=layer) for i in range(N)]\n",
    "\n",
    "routes = gf.routing.get_bundle_path_length_match(ports1, ports2, extra_length=44)\n",
    "for route in routes:\n",
    "    c.add(route.references)\n",
    "    print(route.length)\n",
    "c.show()  # Klayout show\n",
    "c.plot()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### increase number of loops\n",
    "\n",
    "You can also increase the number of loops"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "c = gf.Component(\"path_length_match_sample\")\n",
    "\n",
    "dy = 2000.0\n",
    "xs1 = [-500, -300, -100, -90, -80, -55, -35, 200, 210, 240, 500, 650]\n",
    "\n",
    "pitch = 200.0\n",
    "N = len(xs1)\n",
    "xs2 = [-20 + i * pitch for i in range(N)]\n",
    "\n",
    "a1 = 90\n",
    "a2 = a1 + 180\n",
    "layer = (1, 0)\n",
    "\n",
    "ports1 = [gf.Port(f\"top_{i}\", (xs1[i], 0), 0.5, a1, layer=layer) for i in range(N)]\n",
    "ports2 = [gf.Port(f\"bot_{i}\", (xs2[i], dy), 0.5, a2, layer=layer) for i in range(N)]\n",
    "\n",
    "routes = gf.routing.get_bundle_path_length_match(\n",
    "    ports1, ports2, nb_loops=2, auto_widen=False\n",
    ")\n",
    "for route in routes:\n",
    "    c.add(route.references)\n",
    "    print(route.length)\n",
    "c.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Problem, sometimes when you do path length matching you need to increase the separation\n",
    "import gdsfactory as gf\n",
    "\n",
    "c = gf.Component()\n",
    "c1 = c << gf.components.straight_array(spacing=90)\n",
    "c2 = c << gf.components.straight_array(spacing=5)\n",
    "c2.movex(200)\n",
    "c1.y = 0\n",
    "c2.y = 0\n",
    "\n",
    "routes = gf.routing.get_bundle_path_length_match(\n",
    "    c1.get_ports_list(orientation=0),\n",
    "    c2.get_ports_list(orientation=180),\n",
    "    end_straight_length=0,\n",
    "    start_straight_length=0,\n",
    "    separation=30,\n",
    "    radius=5,\n",
    ")\n",
    "\n",
    "for route in routes:\n",
    "    c.add(route.references)\n",
    "c.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Solution: increase separation\n",
    "import gdsfactory as gf\n",
    "\n",
    "c = gf.Component()\n",
    "c1 = c << gf.components.straight_array(spacing=90)\n",
    "c2 = c << gf.components.straight_array(spacing=5)\n",
    "c2.movex(200)\n",
    "c1.y = 0\n",
    "c2.y = 0\n",
    "\n",
    "routes = gf.routing.get_bundle_path_length_match(\n",
    "    c1.get_ports_list(orientation=0),\n",
    "    c2.get_ports_list(orientation=180),\n",
    "    end_straight_length=0,\n",
    "    start_straight_length=0,\n",
    "    separation=80,  # increased\n",
    "    radius=5,\n",
    ")\n",
    "\n",
    "for route in routes:\n",
    "    c.add(route.references)\n",
    "c.plot()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Route to IO (Pads, grating couplers ...)\n",
    "\n",
    "\n",
    "### Route to electrical pads"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import gdsfactory as gf\n",
    "\n",
    "mzi = gf.components.straight_heater_metal(length=30)\n",
    "mzi.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import gdsfactory as gf\n",
    "\n",
    "mzi = gf.components.mzi_phase_shifter(\n",
    "    length_x=30, straight_x_top=gf.components.straight_heater_metal_90_90\n",
    ")\n",
    "mzi_te = gf.routing.add_electrical_pads_top(component=mzi, layer=(41, 0))\n",
    "mzi_te.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import gdsfactory as gf\n",
    "\n",
    "hr = gf.components.straight_heater_metal()\n",
    "cc = gf.routing.add_electrical_pads_shortest(component=hr, layer=(41, 0))\n",
    "cc.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Problem: Sometimes the shortest path does not work well\n",
    "import gdsfactory as gf\n",
    "\n",
    "c = gf.components.mzi_phase_shifter_top_heater_metal(length_x=70)\n",
    "cc = gf.routing.add_electrical_pads_shortest(component=c, layer=(41, 0))\n",
    "cc.show()\n",
    "cc.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Solution: you can use define the pads separate and route metal lines to them\n",
    "\n",
    "c = gf.Component(\"mzi_with_pads\")\n",
    "c1 = c << gf.components.mzi_phase_shifter_top_heater_metal(length_x=70)\n",
    "c2 = c << gf.components.pad_array(columns=2)\n",
    "\n",
    "c2.ymin = c1.ymax + 20\n",
    "c2.x = 0\n",
    "c1.x = 0\n",
    "c.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "c = gf.Component(\"mzi_with_pads\")\n",
    "c1 = c << gf.components.mzi_phase_shifter(\n",
    "    straight_x_top=gf.components.straight_heater_metal_90_90, length_x=70\n",
    ")\n",
    "c2 = c << gf.components.pad_array(columns=2)\n",
    "\n",
    "c2.ymin = c1.ymax + 20\n",
    "c2.x = 0\n",
    "c1.x = 0\n",
    "\n",
    "ports1 = c1.get_ports_list(width=11)\n",
    "ports2 = c2.get_ports_list()\n",
    "\n",
    "routes = gf.routing.get_bundle(\n",
    "    ports1=ports1,\n",
    "    ports2=ports2,\n",
    "    cross_section=gf.cross_section.metal1,\n",
    "    width=5,\n",
    "    bend=gf.components.wire_corner,\n",
    ")\n",
    "for route in routes:\n",
    "    c.add(route.references)\n",
    "\n",
    "c.plot()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Route to Fiber Array\n",
    "\n",
    "Routing allows you to define routes to optical or electrical IO (grating couplers or electrical pads)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "attributes": {
     "classes": [],
     "id": "",
     "n": "1"
    }
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import gdsfactory as gf\n",
    "from gdsfactory import LAYER\n",
    "from gdsfactory import Port\n",
    "\n",
    "\n",
    "@gf.cell\n",
    "def big_device(w=400.0, h=400.0, N=16, port_pitch=15.0, layer=LAYER.WG, wg_width=0.5):\n",
    "    \"\"\"big component with N ports on each side\"\"\"\n",
    "    component = gf.Component()\n",
    "    p0 = np.array((0, 0))\n",
    "    dx = w / 2\n",
    "    dy = h / 2\n",
    "\n",
    "    points = [[dx, dy], [dx, -dy], [-dx, -dy], [-dx, dy]]\n",
    "    component.add_polygon(points, layer=layer)\n",
    "    port_params = {\"layer\": layer, \"width\": wg_width}\n",
    "    for i in range(N):\n",
    "        port = Port(\n",
    "            name=\"W{}\".format(i),\n",
    "            midpoint=p0 + (-dx, (i - N / 2) * port_pitch),\n",
    "            orientation=180,\n",
    "            **port_params,\n",
    "        )\n",
    "        component.add_port(port)\n",
    "\n",
    "    for i in range(N):\n",
    "        port = Port(\n",
    "            name=\"E{}\".format(i),\n",
    "            midpoint=p0 + (dx, (i - N / 2) * port_pitch),\n",
    "            orientation=0,\n",
    "            **port_params,\n",
    "        )\n",
    "        component.add_port(port)\n",
    "\n",
    "    for i in range(N):\n",
    "        port = Port(\n",
    "            name=\"N{}\".format(i),\n",
    "            midpoint=p0 + ((i - N / 2) * port_pitch, dy),\n",
    "            orientation=90,\n",
    "            **port_params,\n",
    "        )\n",
    "        component.add_port(port)\n",
    "\n",
    "    for i in range(N):\n",
    "        port = Port(\n",
    "            name=\"S{}\".format(i),\n",
    "            midpoint=p0 + ((i - N / 2) * port_pitch, -dy),\n",
    "            orientation=-90,\n",
    "            **port_params,\n",
    "        )\n",
    "        component.add_port(port)\n",
    "    return component\n",
    "\n",
    "\n",
    "component = big_device(N=10)\n",
    "c = gf.routing.add_fiber_array(component=component, radius=10.0, fanout_length=60.0)\n",
    "c.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import gdsfactory as gf\n",
    "\n",
    "c = gf.components.ring_double(width=0.8)\n",
    "cc = gf.routing.add_fiber_array(component=c, taper_length=150)\n",
    "cc.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "cc.pprint()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "You can also mix and match `TE` and `TM` grating couplers"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "c = gf.components.mzi_phase_shifter()\n",
    "gcte = gf.components.grating_coupler_te\n",
    "gctm = gf.components.grating_coupler_tm\n",
    "\n",
    "cc = gf.routing.add_fiber_array(\n",
    "    component=c,\n",
    "    optical_routing_type=2,\n",
    "    grating_coupler=[gctm, gcte, gctm, gcte],\n",
    "    radius=20,\n",
    ")\n",
    "cc.plot()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Route to fiber single"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import gdsfactory as gf\n",
    "\n",
    "c = gf.components.ring_single()\n",
    "cc = gf.routing.add_fiber_single(component=c)\n",
    "cc.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import gdsfactory as gf\n",
    "\n",
    "c = gf.components.ring_single()\n",
    "cc = gf.routing.add_fiber_single(component=c, with_loopback=False)\n",
    "cc.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "c = gf.components.mmi2x2()\n",
    "cc = gf.routing.add_fiber_single(component=c, with_loopback=False)\n",
    "cc.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "c = gf.components.mmi1x2()\n",
    "cc = gf.routing.add_fiber_single(component=c, with_loopback=False, fiber_spacing=150)\n",
    "cc.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "c = gf.components.mmi1x2()\n",
    "cc = gf.routing.add_fiber_single(component=c, with_loopback=False, fiber_spacing=50)\n",
    "cc.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "c = gf.components.crossing()\n",
    "cc = gf.routing.add_fiber_single(component=c, with_loopback=False)\n",
    "cc.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "c = gf.components.cross(length=200, width=2, port_type=\"optical\")\n",
    "cc = gf.routing.add_fiber_single(component=c, with_loopback=False)\n",
    "cc.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "c = gf.components.spiral()\n",
    "cc = gf.routing.add_fiber_single(component=c, with_loopback=False)\n",
    "cc.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.10"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
