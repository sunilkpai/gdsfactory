{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "334fb287-3f67-4828-8ea2-b9ca5bef58cf",
   "metadata": {},
   "source": [
    "# Component -> Circuit -> Mask\n",
    "\n",
    "gdsfactory easily enables you to go from a Component, to a higher level Component (circuit), or even higher level Component (Mask)\n",
    "\n",
    "For a component it's important that you spend some time early to parametrize it correctly. Don't be afraid to spend some time using pen and paper and choosing easy to understand names.\n",
    "\n",
    "Lets for example define a ring resontator. A ring resonator is already a circuit made of waveguides, bends and couplers.\n",
    "\n",
    "\n",
    "## Component\n",
    "\n",
    "You can define any new Component define as a function that returns a component"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "972040a8-0c59-43c0-89d4-aec5c8f527d6",
   "metadata": {},
   "outputs": [],
   "source": [
    "from typing import Optional\n",
    "\n",
    "import gdsfactory as gf\n",
    "from gdsfactory.component import Component\n",
    "from gdsfactory.components.bend_euler import bend_euler\n",
    "from gdsfactory.components.coupler90 import coupler90 as coupler90function\n",
    "from gdsfactory.components.coupler_straight import (\n",
    "    coupler_straight as coupler_straight_function,\n",
    ")\n",
    "from gdsfactory.cross_section import strip\n",
    "from gdsfactory.snap import assert_on_2nm_grid\n",
    "from gdsfactory.types import ComponentSpec, CrossSectionSpec\n",
    "\n",
    "\n",
    "@gf.cell\n",
    "def coupler_ring(\n",
    "    gap: float = 0.2,\n",
    "    radius: float = 5.0,\n",
    "    length_x: float = 4.0,\n",
    "    coupler90: ComponentSpec = coupler90function,\n",
    "    bend: Optional[ComponentSpec] = None,\n",
    "    coupler_straight: ComponentSpec = coupler_straight_function,\n",
    "    cross_section: CrossSectionSpec = strip,\n",
    "    **kwargs\n",
    ") -> Component:\n",
    "    r\"\"\"Coupler for ring.\n",
    "\n",
    "    Args:\n",
    "        gap: spacing between parallel coupled straight waveguides.\n",
    "        radius: of the bends.\n",
    "        length_x: length of the parallel coupled straight waveguides.\n",
    "        coupler90: straight coupled to a 90deg bend.\n",
    "        straight: library for straight waveguides.\n",
    "        bend: library for bend\n",
    "        coupler_straight: two parallel coupled straight waveguides.\n",
    "        cross_section:\n",
    "        kwargs: cross_section settings\n",
    "\n",
    "    .. code::\n",
    "\n",
    "           2             3\n",
    "           |             |\n",
    "            \\           /\n",
    "             \\         /\n",
    "           ---=========---\n",
    "         1    length_x    4\n",
    "\n",
    "\n",
    "    \"\"\"\n",
    "    bend = bend or bend_euler\n",
    "\n",
    "    c = Component()\n",
    "    assert_on_2nm_grid(gap)\n",
    "\n",
    "    # define subcells\n",
    "    coupler90_component = (\n",
    "        coupler90(\n",
    "            gap=gap, radius=radius, bend=bend, cross_section=cross_section, **kwargs\n",
    "        )\n",
    "        if callable(coupler90)\n",
    "        else coupler90\n",
    "    )\n",
    "    coupler_straight_component = (\n",
    "        coupler_straight(\n",
    "            gap=gap, length=length_x, cross_section=cross_section, **kwargs\n",
    "        )\n",
    "        if callable(coupler_straight)\n",
    "        else coupler_straight\n",
    "    )\n",
    "\n",
    "    # add references to subcells\n",
    "    cbl = c << coupler90_component\n",
    "    cbr = c << coupler90_component\n",
    "    cs = c << coupler_straight_component\n",
    "\n",
    "    # connect references\n",
    "    y = coupler90_component.y\n",
    "    cs.connect(port=\"o4\", destination=cbr.ports[\"o1\"])\n",
    "    cbl.reflect(p1=(0, y), p2=(1, y))\n",
    "    cbl.connect(port=\"o2\", destination=cs.ports[\"o2\"])\n",
    "\n",
    "    c.absorb(cbl)\n",
    "    c.absorb(cbr)\n",
    "    c.absorb(cs)\n",
    "\n",
    "    c.add_port(\"o1\", port=cbl.ports[\"o3\"])\n",
    "    c.add_port(\"o2\", port=cbl.ports[\"o4\"])\n",
    "    c.add_port(\"o3\", port=cbr.ports[\"o3\"])\n",
    "    c.add_port(\"o4\", port=cbr.ports[\"o4\"])\n",
    "    c.auto_rename_ports()\n",
    "    return c\n",
    "\n",
    "\n",
    "coupler = coupler_ring(cache=False)\n",
    "coupler.plot()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c5a7dd0c-67c7-461c-b067-cab22fcac287",
   "metadata": {},
   "source": [
    "## Circuits\n",
    "\n",
    "You can define a circuit also with a function, and some of the parameters can also be functions that returns other components\n",
    "\n",
    "For example, lets define a ring function that also accepts other component functions (straight, coupler, bend)\n",
    "\n",
    "\n",
    "### Circuit function"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "08dd1c4b-d0bb-47d3-8af7-544e8a7810e5",
   "metadata": {},
   "outputs": [],
   "source": [
    "import gdsfactory as gf\n",
    "\n",
    "\n",
    "@gf.cell\n",
    "def ring_single(\n",
    "    gap: float = 0.2,\n",
    "    radius: float = 10.0,\n",
    "    length_x: float = 4.0,\n",
    "    length_y: float = 0.6,\n",
    "    coupler_ring: gf.types.ComponentSpec = coupler_ring,\n",
    "    straight: gf.types.ComponentSpec = gf.components.straight,\n",
    "    bend: gf.types.ComponentSpec = gf.components.bend_euler,\n",
    "    cross_section: gf.types.CrossSectionSpec = gf.cross_section.strip,\n",
    "    **kwargs\n",
    ") -> gf.Component:\n",
    "    \"\"\"Single bus ring made of a ring coupler (cb: bottom)\n",
    "    connected with two vertical straights (sl: left, sr: right)\n",
    "    two bends (bl, br) and horizontal straight (wg: top)\n",
    "\n",
    "    Args:\n",
    "        gap: gap between for coupler\n",
    "        radius: for the bend and coupler\n",
    "        length_x: ring coupler length\n",
    "        length_y: vertical straight length\n",
    "        coupler_ring: ring coupler function\n",
    "        straight: straight function\n",
    "        bend: 90 degrees bend function\n",
    "        cross_section:\n",
    "        **kwargs: cross_section settings\n",
    "\n",
    "\n",
    "    .. code::\n",
    "\n",
    "          bl-st-br\n",
    "          |      |\n",
    "          sl     sr length_y\n",
    "          |      |\n",
    "         --==cb==-- gap\n",
    "\n",
    "          length_x\n",
    "\n",
    "    \"\"\"\n",
    "    gf.snap.assert_on_2nm_grid(gap)\n",
    "\n",
    "    coupler_ring = gf.partial(\n",
    "        coupler_ring,\n",
    "        bend=bend,\n",
    "        gap=gap,\n",
    "        radius=radius,\n",
    "        length_x=length_x,\n",
    "        cross_section=cross_section,\n",
    "        **kwargs\n",
    "    )\n",
    "\n",
    "    straight_side = gf.partial(\n",
    "        straight, length=length_y, cross_section=cross_section, **kwargs\n",
    "    )\n",
    "    straight_top = gf.partial(\n",
    "        straight, length=length_x, cross_section=cross_section, **kwargs\n",
    "    )\n",
    "\n",
    "    bend = gf.partial(bend, radius=radius, cross_section=cross_section, **kwargs)\n",
    "\n",
    "    c = gf.Component()\n",
    "    cb = c << coupler_ring()\n",
    "    sl = c << straight_side()\n",
    "    sr = c << straight_side()\n",
    "    bl = c << bend()\n",
    "    br = c << bend()\n",
    "    st = c << straight_top()\n",
    "    # st.mirror(p1=(0, 0), p2=(1, 0))\n",
    "\n",
    "    sl.connect(port=\"o1\", destination=cb.ports[\"o2\"])\n",
    "    bl.connect(port=\"o2\", destination=sl.ports[\"o2\"])\n",
    "\n",
    "    st.connect(port=\"o2\", destination=bl.ports[\"o1\"])\n",
    "    br.connect(port=\"o2\", destination=st.ports[\"o1\"])\n",
    "    sr.connect(port=\"o1\", destination=br.ports[\"o1\"])\n",
    "    sr.connect(port=\"o2\", destination=cb.ports[\"o3\"])\n",
    "\n",
    "    c.add_port(\"o2\", port=cb.ports[\"o4\"])\n",
    "    c.add_port(\"o1\", port=cb.ports[\"o1\"])\n",
    "    return c\n",
    "\n",
    "\n",
    "ring = ring_single()\n",
    "ring.plot()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "be6a2a0e-d35c-4e0c-be9c-cc16b1aa0bf9",
   "metadata": {},
   "source": [
    "How do you customize components?\n",
    "\n",
    "You can use `functools.partial` to customize the default settings from any component"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2221442b-b501-4cb1-9af7-0249500179b6",
   "metadata": {},
   "outputs": [],
   "source": [
    "ring_single3 = gf.partial(ring_single, radius=3)\n",
    "ring_single3()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e68e75b2-625d-4bd5-adbb-5bfc22858bff",
   "metadata": {},
   "source": [
    "### Circuit netlist\n",
    "\n",
    "Sometimes, when a component is mostly composed of sub-components adjacent to each\n",
    "other, it can be easier to define the component by sub-component connections and by which ports are part of the new components.\n",
    "\n",
    "This can be done using a netlist based approach where these 3 parts are defined:\n",
    "\n",
    "- components: a dictionary of `{component reference name: (component, transform)}`\n",
    "- connections: a list of `(component ref name 1, port name A, component ref name 2, port name B)`\n",
    "- ports_map: a dictionary of which ports are being exposed together with their new name `{port_name: (component ref name, port name)}`\n",
    "\n",
    "The code below illustrates how a simple MZI can be formed using this method."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "67bd29c0-a30d-4e30-8c36-f9a27abe27c4",
   "metadata": {},
   "outputs": [],
   "source": [
    "import gdsfactory as gf\n",
    "\n",
    "yaml = \"\"\"\n",
    "name: simple_mzi\n",
    "instances:\n",
    "    mmi1:\n",
    "      component: mmi1x2\n",
    "      settings:\n",
    "        width_mmi: 4.5\n",
    "        length_mmi: 10\n",
    "    mmi2:\n",
    "      component: mmi1x2\n",
    "      settings:\n",
    "        width_mmi: 4.5\n",
    "        length_mmi: 5\n",
    "    \n",
    "    straight:\n",
    "        component: straight\n",
    "\n",
    "placements:\n",
    "    mmi2:\n",
    "        x: 100\n",
    "        mirror: True\n",
    "    \n",
    "    straight:\n",
    "        x: 40\n",
    "        y: 40\n",
    "\n",
    "routes:\n",
    "    route_name1:\n",
    "        links:\n",
    "            mmi1,o3: mmi2,o3\n",
    "    route_name2:\n",
    "        links:\n",
    "            mmi1,o2: straight,o1\n",
    "    route_name3:\n",
    "        links:\n",
    "            mmi2,o2: straight,o2\n",
    "\n",
    "\"\"\"\n",
    "\n",
    "mzi = gf.read.from_yaml(yaml)\n",
    "mzi.show()\n",
    "mzi.plot()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "abd3046b-79bb-46fe-afbf-965ba26f12a5",
   "metadata": {},
   "source": [
    "Exporting connectivity map from a GDS is the first step towards verification.\n",
    "\n",
    "- Adding ports to *every* cells in the GDS\n",
    "- Generating the netlist\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "be4b2718-442f-435c-830d-01cecef01ca1",
   "metadata": {},
   "outputs": [],
   "source": [
    "mzi.plot_netlist()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "631d78f4-bda9-4daf-aaa1-785765043ad8",
   "metadata": {},
   "source": [
    "## Mask\n",
    "\n",
    "Once you have your components and circuits defined, you can add them into a mask that you will send to the foundry for fabrication.\n",
    "\n",
    "You will need to consider:\n",
    "\n",
    "- what design variations do you want to include in the mask? You need to define your Design Of Experiment or DOE\n",
    "- obey DRC (Design rule checking) foundry rules for manufacturability. Foundry usually provides those rules for each layer (min width, min space, min density, max density)\n",
    "- make sure you will be able to test te devices after fabriation. Obey DFT (design for testing) rules. For exammple, if your test setup works only for fiber array, what is the fiber array spacing (127 or 250um?)\n",
    "- if you plan to package your device, make sure you follow your packaging guidelines from your packaging house (min pad size, min pad pitch, max number of rows for wire bonding ...)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9f40780c-8be2-4f76-b412-b17f419a44b6",
   "metadata": {},
   "outputs": [],
   "source": [
    "import toolz\n",
    "import gdsfactory as gf\n",
    "\n",
    "ring_te = toolz.compose(gf.routing.add_fiber_array, gf.components.ring_single)\n",
    "rings = gf.grid([ring_te(radius=r) for r in [10, 20, 50]])\n",
    "\n",
    "\n",
    "@gf.cell\n",
    "def mask(size=(1000, 1000)):\n",
    "    c = gf.Component()\n",
    "    c << gf.components.die(size=size)\n",
    "    c << rings\n",
    "    return c\n",
    "\n",
    "\n",
    "m = mask(cache=False)\n",
    "m"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ca0e9788-4035-4585-96df-91d3d072625b",
   "metadata": {},
   "outputs": [],
   "source": [
    "gdspath = m.write_gds_with_metadata(gdspath=\"mask.gds\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a75d3e70-7821-4f70-b054-b95ede84a85f",
   "metadata": {},
   "source": [
    "Make sure you save the GDS with metadata so when the chip comes back you remember what you put on it\n",
    "\n",
    "You can also save the labels for automatic testing."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "67d8d3bb-1695-423b-89e3-b2abf473ced4",
   "metadata": {},
   "outputs": [],
   "source": [
    "labels_path = gdspath.with_suffix(\".csv\")\n",
    "gf.mask.write_labels(gdspath=gdspath, layer_label=(66, 0))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f8823f78-0db8-4cd6-8164-db3268d4c68a",
   "metadata": {},
   "outputs": [],
   "source": [
    "mask_metadata = gf.mask.read_metadata(gdspath=gdspath)\n",
    "tm = gf.mask.merge_test_metadata(mask_metadata=mask_metadata, labels_path=labels_path)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a677753f-ae26-4aa6-8a89-4c87aa4e8bf6",
   "metadata": {},
   "outputs": [],
   "source": [
    "tm.keys()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ab3e9546-5ad1-40e0-ae02-358d9a82566c",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.10"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
